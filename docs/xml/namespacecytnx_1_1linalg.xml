<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.5" xml:lang="en-US">
  <compounddef id="namespacecytnx_1_1linalg" kind="namespace" language="C++">
    <compoundname>cytnx::linalg</compoundname>
      <sectiondef kind="func">
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1ac61bd0f99306496fae81f8601fa4070c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref></type>
        <definition>cytnx::UniTensor cytnx::linalg::Add</definition>
        <argsstring>(const cytnx::UniTensor &amp;Lt, const cytnx::UniTensor &amp;Rt)</argsstring>
        <name>Add</name>
        <qualifiedname>cytnx::linalg::Add</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref> &amp;</type>
          <declname>Lt</declname>
        </param>
        <param>
          <type>const <ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref> &amp;</type>
          <declname>Rt</declname>
        </param>
        <briefdescription>
<para>element-wise add </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="57" column="22" declfile="include/linalg.hpp" declline="57" declcolumn="22"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1af647a78f613d4377416099338d1b6e5e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref></type>
        <definition>cytnx::UniTensor cytnx::linalg::Add</definition>
        <argsstring>(const T &amp;lc, const cytnx::UniTensor &amp;Rt)</argsstring>
        <name>Add</name>
        <qualifiedname>cytnx::linalg::Add</qualifiedname>
        <param>
          <type>const T &amp;</type>
          <declname>lc</declname>
        </param>
        <param>
          <type>const <ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref> &amp;</type>
          <declname>Rt</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="59" column="22" declfile="include/linalg.hpp" declline="59" declcolumn="22"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a28915f5d2748f9dfff9252a5f2faf3fb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref></type>
        <definition>cytnx::UniTensor cytnx::linalg::Add</definition>
        <argsstring>(const cytnx::UniTensor &amp;Lt, const T &amp;rc)</argsstring>
        <name>Add</name>
        <qualifiedname>cytnx::linalg::Add</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref> &amp;</type>
          <declname>Lt</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>rc</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="61" column="22" declfile="include/linalg.hpp" declline="61" declcolumn="22"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a9918295b0d2d78fa475390e91ccbf57b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref></type>
        <definition>cytnx::UniTensor cytnx::linalg::Sub</definition>
        <argsstring>(const cytnx::UniTensor &amp;Lt, const cytnx::UniTensor &amp;Rt)</argsstring>
        <name>Sub</name>
        <qualifiedname>cytnx::linalg::Sub</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref> &amp;</type>
          <declname>Lt</declname>
        </param>
        <param>
          <type>const <ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref> &amp;</type>
          <declname>Rt</declname>
        </param>
        <briefdescription>
<para>element-wise subtract </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="68" column="22" declfile="include/linalg.hpp" declline="68" declcolumn="22"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a93d15a4d2fa012d77683cb7e191ff7e9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref></type>
        <definition>cytnx::UniTensor cytnx::linalg::Sub</definition>
        <argsstring>(const T &amp;lc, const cytnx::UniTensor &amp;Rt)</argsstring>
        <name>Sub</name>
        <qualifiedname>cytnx::linalg::Sub</qualifiedname>
        <param>
          <type>const T &amp;</type>
          <declname>lc</declname>
        </param>
        <param>
          <type>const <ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref> &amp;</type>
          <declname>Rt</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="70" column="22" declfile="include/linalg.hpp" declline="70" declcolumn="22"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a46100e202b84bb40817ba0e3c0d628c1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref></type>
        <definition>cytnx::UniTensor cytnx::linalg::Sub</definition>
        <argsstring>(const cytnx::UniTensor &amp;Lt, const T &amp;rc)</argsstring>
        <name>Sub</name>
        <qualifiedname>cytnx::linalg::Sub</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref> &amp;</type>
          <declname>Lt</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>rc</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="72" column="22" declfile="include/linalg.hpp" declline="72" declcolumn="22"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a8705f85e347439577708173ab963f909" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref></type>
        <definition>cytnx::UniTensor cytnx::linalg::Mul</definition>
        <argsstring>(const cytnx::UniTensor &amp;Lt, const cytnx::UniTensor &amp;Rt)</argsstring>
        <name>Mul</name>
        <qualifiedname>cytnx::linalg::Mul</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref> &amp;</type>
          <declname>Lt</declname>
        </param>
        <param>
          <type>const <ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref> &amp;</type>
          <declname>Rt</declname>
        </param>
        <briefdescription>
<para>element-wise subtract </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="79" column="22" declfile="include/linalg.hpp" declline="79" declcolumn="22"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a251b0520dee5ccd09626cae97288e775" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref></type>
        <definition>cytnx::UniTensor cytnx::linalg::Mul</definition>
        <argsstring>(const T &amp;lc, const cytnx::UniTensor &amp;Rt)</argsstring>
        <name>Mul</name>
        <qualifiedname>cytnx::linalg::Mul</qualifiedname>
        <param>
          <type>const T &amp;</type>
          <declname>lc</declname>
        </param>
        <param>
          <type>const <ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref> &amp;</type>
          <declname>Rt</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="81" column="22" declfile="include/linalg.hpp" declline="81" declcolumn="22"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a37bc8d705dd0d70074d2df47cdadc0a6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref></type>
        <definition>cytnx::UniTensor cytnx::linalg::Mul</definition>
        <argsstring>(const cytnx::UniTensor &amp;Lt, const T &amp;rc)</argsstring>
        <name>Mul</name>
        <qualifiedname>cytnx::linalg::Mul</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref> &amp;</type>
          <declname>Lt</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>rc</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="83" column="22" declfile="include/linalg.hpp" declline="83" declcolumn="22"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1affc6138760ac67505ae194edf14525e8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref></type>
        <definition>cytnx::UniTensor cytnx::linalg::Div</definition>
        <argsstring>(const cytnx::UniTensor &amp;Lt, const cytnx::UniTensor &amp;Rt)</argsstring>
        <name>Div</name>
        <qualifiedname>cytnx::linalg::Div</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref> &amp;</type>
          <declname>Lt</declname>
        </param>
        <param>
          <type>const <ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref> &amp;</type>
          <declname>Rt</declname>
        </param>
        <briefdescription>
<para>element-wise divide </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="90" column="22" declfile="include/linalg.hpp" declline="90" declcolumn="22"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a122b2e7f195bbb1b5febc2cb09ebeb67" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref></type>
        <definition>cytnx::UniTensor cytnx::linalg::Div</definition>
        <argsstring>(const T &amp;lc, const cytnx::UniTensor &amp;Rt)</argsstring>
        <name>Div</name>
        <qualifiedname>cytnx::linalg::Div</qualifiedname>
        <param>
          <type>const T &amp;</type>
          <declname>lc</declname>
        </param>
        <param>
          <type>const <ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref> &amp;</type>
          <declname>Rt</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="92" column="22" declfile="include/linalg.hpp" declline="92" declcolumn="22"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1afdb69bcb0d23f46ded824ef33321c4ab" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref></type>
        <definition>cytnx::UniTensor cytnx::linalg::Div</definition>
        <argsstring>(const cytnx::UniTensor &amp;Lt, const T &amp;rc)</argsstring>
        <name>Div</name>
        <qualifiedname>cytnx::linalg::Div</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref> &amp;</type>
          <declname>Lt</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>rc</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="94" column="22" declfile="include/linalg.hpp" declline="94" declcolumn="22"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a56d73db3d0cdd3a2ca5ed5f88f0738ff" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref></type>
        <definition>cytnx::UniTensor cytnx::linalg::Mod</definition>
        <argsstring>(const cytnx::UniTensor &amp;Lt, const cytnx::UniTensor &amp;Rt)</argsstring>
        <name>Mod</name>
        <qualifiedname>cytnx::linalg::Mod</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref> &amp;</type>
          <declname>Lt</declname>
        </param>
        <param>
          <type>const <ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref> &amp;</type>
          <declname>Rt</declname>
        </param>
        <briefdescription>
<para>element-wise modulo </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="101" column="22" declfile="include/linalg.hpp" declline="101" declcolumn="22"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a024c4293a5b5edfb432b9c15e4199264" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref></type>
        <definition>cytnx::UniTensor cytnx::linalg::Mod</definition>
        <argsstring>(const T &amp;lc, const cytnx::UniTensor &amp;Rt)</argsstring>
        <name>Mod</name>
        <qualifiedname>cytnx::linalg::Mod</qualifiedname>
        <param>
          <type>const T &amp;</type>
          <declname>lc</declname>
        </param>
        <param>
          <type>const <ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref> &amp;</type>
          <declname>Rt</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="103" column="22" declfile="include/linalg.hpp" declline="103" declcolumn="22"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a0a1378cb7fdd0bdd7445ee98805c85b7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref></type>
        <definition>cytnx::UniTensor cytnx::linalg::Mod</definition>
        <argsstring>(const cytnx::UniTensor &amp;Lt, const T &amp;rc)</argsstring>
        <name>Mod</name>
        <qualifiedname>cytnx::linalg::Mod</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref> &amp;</type>
          <declname>Lt</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>rc</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="105" column="22" declfile="include/linalg.hpp" declline="105" declcolumn="22"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1ad3681539523188fce02d6332cfa1ffd1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; <ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref> &gt;</type>
        <definition>std::vector&lt; cytnx::UniTensor &gt; cytnx::linalg::Svd</definition>
        <argsstring>(const cytnx::UniTensor &amp;Tin, const bool &amp;is_U=true, const bool &amp;is_vT=true)</argsstring>
        <name>Svd</name>
        <qualifiedname>cytnx::linalg::Svd</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref> &amp;</type>
          <declname>Tin</declname>
        </param>
        <param>
          <type>const bool &amp;</type>
          <declname>is_U</declname>
          <defval>true</defval>
        </param>
        <param>
          <type>const bool &amp;</type>
          <declname>is_vT</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="107" column="17" declfile="include/linalg.hpp" declline="107" declcolumn="17"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a73ad52d4027c912fe24ffdffc2d893f8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; <ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref> &gt;</type>
        <definition>std::vector&lt; cytnx::UniTensor &gt; cytnx::linalg::Svd_truncate</definition>
        <argsstring>(const cytnx::UniTensor &amp;Tin, const cytnx_uint64 &amp;keepdim, const double &amp;err=0, const bool &amp;is_U=true, const bool &amp;is_vT=true, const bool &amp;return_err=false)</argsstring>
        <name>Svd_truncate</name>
        <qualifiedname>cytnx::linalg::Svd_truncate</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref> &amp;</type>
          <declname>Tin</declname>
        </param>
        <param>
          <type>const <ref refid="namespacecytnx_1a9a7ab808c7cbef775461ccc31eaabeb4" kindref="member">cytnx_uint64</ref> &amp;</type>
          <declname>keepdim</declname>
        </param>
        <param>
          <type>const double &amp;</type>
          <declname>err</declname>
          <defval>0</defval>
        </param>
        <param>
          <type>const bool &amp;</type>
          <declname>is_U</declname>
          <defval>true</defval>
        </param>
        <param>
          <type>const bool &amp;</type>
          <declname>is_vT</declname>
          <defval>true</defval>
        </param>
        <param>
          <type>const bool &amp;</type>
          <declname>return_err</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="109" column="17" declfile="include/linalg.hpp" declline="109" declcolumn="17"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1aa1a08b9294b199a6d56f5f5aa2fa58cc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; <ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref> &gt;</type>
        <definition>std::vector&lt; cytnx::UniTensor &gt; cytnx::linalg::Hosvd</definition>
        <argsstring>(const cytnx::UniTensor &amp;Tin, const std::vector&lt; cytnx_uint64 &gt; &amp;mode, const bool &amp;is_core=true, const bool &amp;is_Ls=false, const std::vector&lt; cytnx_int64 &gt; &amp;trucate_dim=std::vector&lt; cytnx_int64 &gt;())</argsstring>
        <name>Hosvd</name>
        <qualifiedname>cytnx::linalg::Hosvd</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref> &amp;</type>
          <declname>Tin</declname>
        </param>
        <param>
          <type>const std::vector&lt; <ref refid="namespacecytnx_1a9a7ab808c7cbef775461ccc31eaabeb4" kindref="member">cytnx_uint64</ref> &gt; &amp;</type>
          <declname>mode</declname>
        </param>
        <param>
          <type>const bool &amp;</type>
          <declname>is_core</declname>
          <defval>true</defval>
        </param>
        <param>
          <type>const bool &amp;</type>
          <declname>is_Ls</declname>
          <defval>false</defval>
        </param>
        <param>
          <type>const std::vector&lt; <ref refid="namespacecytnx_1aa7b7ff4d6d244994d35853a6ce547587" kindref="member">cytnx_int64</ref> &gt; &amp;</type>
          <declname>trucate_dim</declname>
          <defval>std::vector&lt; <ref refid="namespacecytnx_1aa7b7ff4d6d244994d35853a6ce547587" kindref="member">cytnx_int64</ref> &gt;()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="113" column="17" declfile="include/linalg.hpp" declline="113" declcolumn="17"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1ae394378db613a244ad518504047669c0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref></type>
        <definition>cytnx::UniTensor cytnx::linalg::ExpH</definition>
        <argsstring>(const cytnx::UniTensor &amp;Tin, const T &amp;a, const T &amp;b=0)</argsstring>
        <name>ExpH</name>
        <qualifiedname>cytnx::linalg::ExpH</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref> &amp;</type>
          <declname>Tin</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>b</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="119" column="22" declfile="include/linalg.hpp" declline="119" declcolumn="22"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1ad5c478aa9da366c15ec7a2351dc99d93" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref></type>
        <definition>cytnx::UniTensor cytnx::linalg::ExpM</definition>
        <argsstring>(const cytnx::UniTensor &amp;Tin, const T &amp;a, const T &amp;b=0)</argsstring>
        <name>ExpM</name>
        <qualifiedname>cytnx::linalg::ExpM</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref> &amp;</type>
          <declname>Tin</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>b</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="121" column="22" declfile="include/linalg.hpp" declline="121" declcolumn="22"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a5343eaa08465151a60d716887b071584" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref></type>
        <definition>cytnx::UniTensor cytnx::linalg::ExpH</definition>
        <argsstring>(const cytnx::UniTensor &amp;Tin)</argsstring>
        <name>ExpH</name>
        <qualifiedname>cytnx::linalg::ExpH</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref> &amp;</type>
          <declname>Tin</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="123" column="22" declfile="include/linalg.hpp" declline="123" declcolumn="22"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1abd3811f5c8c7ca20ab294a751f937f0e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref></type>
        <definition>cytnx::UniTensor cytnx::linalg::ExpM</definition>
        <argsstring>(const cytnx::UniTensor &amp;Tin)</argsstring>
        <name>ExpM</name>
        <qualifiedname>cytnx::linalg::ExpM</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref> &amp;</type>
          <declname>Tin</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="124" column="22" declfile="include/linalg.hpp" declline="124" declcolumn="22"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a2345742316261ec8d04ceb2797c6b521" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref></type>
        <definition>cytnx::UniTensor cytnx::linalg::Trace</definition>
        <argsstring>(const cytnx::UniTensor &amp;Tin, const cytnx_int64 &amp;a=0, const cytnx_int64 &amp;b=1)</argsstring>
        <name>Trace</name>
        <qualifiedname>cytnx::linalg::Trace</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref> &amp;</type>
          <declname>Tin</declname>
        </param>
        <param>
          <type>const <ref refid="namespacecytnx_1aa7b7ff4d6d244994d35853a6ce547587" kindref="member">cytnx_int64</ref> &amp;</type>
          <declname>a</declname>
          <defval>0</defval>
        </param>
        <param>
          <type>const <ref refid="namespacecytnx_1aa7b7ff4d6d244994d35853a6ce547587" kindref="member">cytnx_int64</ref> &amp;</type>
          <declname>b</declname>
          <defval>1</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="127" column="22" declfile="include/linalg.hpp" declline="127" declcolumn="22"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1ad5acb5c8d20b164b52affdd2e747e46b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref></type>
        <definition>cytnx::UniTensor cytnx::linalg::Trace</definition>
        <argsstring>(const cytnx::UniTensor &amp;Tin, const std::string &amp;a, const std::string &amp;b)</argsstring>
        <name>Trace</name>
        <qualifiedname>cytnx::linalg::Trace</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref> &amp;</type>
          <declname>Tin</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="129" column="22" declfile="include/linalg.hpp" declline="129" declcolumn="22"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1aafa45cb5f3b55c204b33c3ab09951af1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref></type>
        <definition>cytnx::UniTensor cytnx::linalg::Trace</definition>
        <argsstring>(const cytnx::UniTensor &amp;Tin, const cytnx_int64 &amp;a=0, const cytnx_int64 &amp;b=1, const bool &amp;by_label=false)</argsstring>
        <name>Trace</name>
        <qualifiedname>cytnx::linalg::Trace</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref> &amp;</type>
          <declname>Tin</declname>
        </param>
        <param>
          <type>const <ref refid="namespacecytnx_1aa7b7ff4d6d244994d35853a6ce547587" kindref="member">cytnx_int64</ref> &amp;</type>
          <declname>a</declname>
          <defval>0</defval>
        </param>
        <param>
          <type>const <ref refid="namespacecytnx_1aa7b7ff4d6d244994d35853a6ce547587" kindref="member">cytnx_int64</ref> &amp;</type>
          <declname>b</declname>
          <defval>1</defval>
        </param>
        <param>
          <type>const bool &amp;</type>
          <declname>by_label</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="130" column="22" declfile="include/linalg.hpp" declline="130" declcolumn="22"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a194461432b34c60984a02569a4d9c903" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; <ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref> &gt;</type>
        <definition>std::vector&lt; cytnx::UniTensor &gt; cytnx::linalg::Qr</definition>
        <argsstring>(const cytnx::UniTensor &amp;Tin, const bool &amp;is_tau=false)</argsstring>
        <name>Qr</name>
        <qualifiedname>cytnx::linalg::Qr</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref> &amp;</type>
          <declname>Tin</declname>
        </param>
        <param>
          <type>const bool &amp;</type>
          <declname>is_tau</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="132" column="17" declfile="include/linalg.hpp" declline="132" declcolumn="17"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1ac3a4d9f746e4d05555de50ac9fca9a77" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; <ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref> &gt;</type>
        <definition>std::vector&lt; cytnx::UniTensor &gt; cytnx::linalg::Qdr</definition>
        <argsstring>(const cytnx::UniTensor &amp;Tin, const bool &amp;is_tau=false)</argsstring>
        <name>Qdr</name>
        <qualifiedname>cytnx::linalg::Qdr</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1UniTensor" kindref="compound">cytnx::UniTensor</ref> &amp;</type>
          <declname>Tin</declname>
        </param>
        <param>
          <type>const bool &amp;</type>
          <declname>is_tau</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="133" column="17" declfile="include/linalg.hpp" declline="133" declcolumn="17"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1af2e15ace1ea23939174fdea1829430fd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcytnx_1_1UniTensor" kindref="compound">UniTensor</ref></type>
        <definition>UniTensor cytnx::linalg::Pow</definition>
        <argsstring>(const UniTensor &amp;Tin, const double &amp;p)</argsstring>
        <name>Pow</name>
        <qualifiedname>cytnx::linalg::Pow</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1UniTensor" kindref="compound">UniTensor</ref> &amp;</type>
          <declname>Tin</declname>
        </param>
        <param>
          <type>const double &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
<para>take power p on all the elements in <ref refid="classcytnx_1_1UniTensor" kindref="compound">UniTensor</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
<parametername>the</parametername>
</parameternamelist>
<parameterdescription>
<para>power </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>[<ref refid="classcytnx_1_1UniTensor" kindref="compound">UniTensor</ref>] </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="144" column="15" declfile="include/linalg.hpp" declline="144" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a31c366a1a4ea1c78e855cb6a79cb6115" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void cytnx::linalg::Pow_</definition>
        <argsstring>(UniTensor &amp;Tin, const double &amp;p)</argsstring>
        <name>Pow_</name>
        <qualifiedname>cytnx::linalg::Pow_</qualifiedname>
        <param>
          <type><ref refid="classcytnx_1_1UniTensor" kindref="compound">UniTensor</ref> &amp;</type>
          <declname>Tin</declname>
        </param>
        <param>
          <type>const double &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
<para>inplace perform power on all the elements in <ref refid="classcytnx_1_1UniTensor" kindref="compound">UniTensor</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>Tin</parametername>
<parametername>the</parametername>
</parameternamelist>
<parameterdescription>
<para>input <ref refid="classcytnx_1_1UniTensor" kindref="compound">UniTensor</ref>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>p</parametername>
<parametername>the</parametername>
</parameternamelist>
<parameterdescription>
<para>power.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
description: on return, the elements in Tin will be modified to it&apos;s exponetial value. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="154" column="10" declfile="include/linalg.hpp" declline="154" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1af36e9e20e4c7d74f2f6f838902482d98" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor cytnx::linalg::Add</definition>
        <argsstring>(const Tensor &amp;Lt, const Tensor &amp;Rt)</argsstring>
        <name>Add</name>
        <qualifiedname>cytnx::linalg::Add</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Lt</declname>
        </param>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Rt</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="162" column="12" declfile="include/linalg.hpp" declline="162" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a33643657d8cc96b037818e2003c049c7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor cytnx::linalg::Add</definition>
        <argsstring>(const T &amp;lc, const Tensor &amp;Rt)</argsstring>
        <name>Add</name>
        <qualifiedname>cytnx::linalg::Add</qualifiedname>
        <param>
          <type>const T &amp;</type>
          <declname>lc</declname>
        </param>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Rt</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="164" column="12" declfile="include/linalg.hpp" declline="164" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1ae158543bf09e9e6914eab96995015d9e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor cytnx::linalg::Add</definition>
        <argsstring>(const Tensor &amp;Lt, const T &amp;rc)</argsstring>
        <name>Add</name>
        <qualifiedname>cytnx::linalg::Add</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Lt</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>rc</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="166" column="12" declfile="include/linalg.hpp" declline="166" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1adcc9a0ef0b78b0e43a66eea808c77594" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void cytnx::linalg::iAdd</definition>
        <argsstring>(Tensor &amp;Lt, const Tensor &amp;Rt)</argsstring>
        <name>iAdd</name>
        <qualifiedname>cytnx::linalg::iAdd</qualifiedname>
        <param>
          <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Lt</declname>
        </param>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Rt</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="168" column="10" declfile="include/linalg.hpp" declline="168" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a78477b25b3eed121847f1a13b878a925" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor cytnx::linalg::Sub</definition>
        <argsstring>(const Tensor &amp;Lt, const Tensor &amp;Rt)</argsstring>
        <name>Sub</name>
        <qualifiedname>cytnx::linalg::Sub</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Lt</declname>
        </param>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Rt</declname>
        </param>
        <briefdescription>
<para>element-wise subtract </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="175" column="12" declfile="include/linalg.hpp" declline="175" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a4fa0cd62f3723518ae4e46db00d8be50" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor cytnx::linalg::Sub</definition>
        <argsstring>(const T &amp;lc, const Tensor &amp;Rt)</argsstring>
        <name>Sub</name>
        <qualifiedname>cytnx::linalg::Sub</qualifiedname>
        <param>
          <type>const T &amp;</type>
          <declname>lc</declname>
        </param>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Rt</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="177" column="12" declfile="include/linalg.hpp" declline="177" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a0fa9fc16ad7e8d2685d0acfa25efc479" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor cytnx::linalg::Sub</definition>
        <argsstring>(const Tensor &amp;Lt, const T &amp;rc)</argsstring>
        <name>Sub</name>
        <qualifiedname>cytnx::linalg::Sub</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Lt</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>rc</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="179" column="12" declfile="include/linalg.hpp" declline="179" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a2683918483159953c002fe09fae0929b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void cytnx::linalg::iSub</definition>
        <argsstring>(Tensor &amp;Lt, const Tensor &amp;Rt)</argsstring>
        <name>iSub</name>
        <qualifiedname>cytnx::linalg::iSub</qualifiedname>
        <param>
          <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Lt</declname>
        </param>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Rt</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="181" column="10" declfile="include/linalg.hpp" declline="181" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a2fc49876b7b53f6f6e97ce70f475f636" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor cytnx::linalg::Mul</definition>
        <argsstring>(const Tensor &amp;Lt, const Tensor &amp;Rt)</argsstring>
        <name>Mul</name>
        <qualifiedname>cytnx::linalg::Mul</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Lt</declname>
        </param>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Rt</declname>
        </param>
        <briefdescription>
<para>element-wise subtract </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="188" column="12" declfile="include/linalg.hpp" declline="188" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a2d21f1d35bcecf3e257146540c668779" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor cytnx::linalg::Mul</definition>
        <argsstring>(const T &amp;lc, const Tensor &amp;Rt)</argsstring>
        <name>Mul</name>
        <qualifiedname>cytnx::linalg::Mul</qualifiedname>
        <param>
          <type>const T &amp;</type>
          <declname>lc</declname>
        </param>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Rt</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="190" column="12" declfile="include/linalg.hpp" declline="190" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a5b2930a8759b8ceb7cd92df6b27bdf24" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor cytnx::linalg::Mul</definition>
        <argsstring>(const Tensor &amp;Lt, const T &amp;rc)</argsstring>
        <name>Mul</name>
        <qualifiedname>cytnx::linalg::Mul</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Lt</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>rc</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="192" column="12" declfile="include/linalg.hpp" declline="192" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1afb6077bb2282f7d164315481a5f7cb4d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void cytnx::linalg::iMul</definition>
        <argsstring>(Tensor &amp;Lt, const Tensor &amp;Rt)</argsstring>
        <name>iMul</name>
        <qualifiedname>cytnx::linalg::iMul</qualifiedname>
        <param>
          <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Lt</declname>
        </param>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Rt</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="194" column="10" declfile="include/linalg.hpp" declline="194" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1abc1940e0e7364299ea1481c81003ba13" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor cytnx::linalg::Div</definition>
        <argsstring>(const Tensor &amp;Lt, const Tensor &amp;Rt)</argsstring>
        <name>Div</name>
        <qualifiedname>cytnx::linalg::Div</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Lt</declname>
        </param>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Rt</declname>
        </param>
        <briefdescription>
<para>element-wise divide </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="201" column="12" declfile="include/linalg.hpp" declline="201" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1acb8965e9a67906d0c8064725c7d499a8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor cytnx::linalg::Div</definition>
        <argsstring>(const T &amp;lc, const Tensor &amp;Rt)</argsstring>
        <name>Div</name>
        <qualifiedname>cytnx::linalg::Div</qualifiedname>
        <param>
          <type>const T &amp;</type>
          <declname>lc</declname>
        </param>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Rt</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="203" column="12" declfile="include/linalg.hpp" declline="203" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a9296701c7aad0456965f42b8ea01ad2e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor cytnx::linalg::Div</definition>
        <argsstring>(const Tensor &amp;Lt, const T &amp;rc)</argsstring>
        <name>Div</name>
        <qualifiedname>cytnx::linalg::Div</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Lt</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>rc</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="205" column="12" declfile="include/linalg.hpp" declline="205" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1ac4f2dc588ac44dfb8bf75efd8182ac47" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void cytnx::linalg::iDiv</definition>
        <argsstring>(Tensor &amp;Lt, const Tensor &amp;Rt)</argsstring>
        <name>iDiv</name>
        <qualifiedname>cytnx::linalg::iDiv</qualifiedname>
        <param>
          <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Lt</declname>
        </param>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Rt</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="207" column="10" declfile="include/linalg.hpp" declline="207" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1ab8ac85bd0291ab12523eec073aef1fa3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor cytnx::linalg::Mod</definition>
        <argsstring>(const Tensor &amp;Lt, const Tensor &amp;Rt)</argsstring>
        <name>Mod</name>
        <qualifiedname>cytnx::linalg::Mod</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Lt</declname>
        </param>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Rt</declname>
        </param>
        <briefdescription>
<para>element-wise divide </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="214" column="12" declfile="include/linalg.hpp" declline="214" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a6c9fca4a4fd4cea1738babc120e51690" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor cytnx::linalg::Mod</definition>
        <argsstring>(const T &amp;lc, const Tensor &amp;Rt)</argsstring>
        <name>Mod</name>
        <qualifiedname>cytnx::linalg::Mod</qualifiedname>
        <param>
          <type>const T &amp;</type>
          <declname>lc</declname>
        </param>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Rt</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="216" column="12" declfile="include/linalg.hpp" declline="216" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a35ed41287fa71215d4575de818f02e43" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor cytnx::linalg::Mod</definition>
        <argsstring>(const Tensor &amp;Lt, const T &amp;rc)</argsstring>
        <name>Mod</name>
        <qualifiedname>cytnx::linalg::Mod</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Lt</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>rc</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="218" column="12" declfile="include/linalg.hpp" declline="218" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1aea125f2928934007725809426bb77e38" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor cytnx::linalg::Cpr</definition>
        <argsstring>(const Tensor &amp;Lt, const Tensor &amp;Rt)</argsstring>
        <name>Cpr</name>
        <qualifiedname>cytnx::linalg::Cpr</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Lt</declname>
        </param>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Rt</declname>
        </param>
        <briefdescription>
<para>element-wise compare </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="225" column="12" declfile="include/linalg.hpp" declline="225" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a12d6a02bc402d9ae1bb7652f7ec92865" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor cytnx::linalg::Cpr</definition>
        <argsstring>(const T &amp;lc, const Tensor &amp;Rt)</argsstring>
        <name>Cpr</name>
        <qualifiedname>cytnx::linalg::Cpr</qualifiedname>
        <param>
          <type>const T &amp;</type>
          <declname>lc</declname>
        </param>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Rt</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="227" column="12" declfile="include/linalg.hpp" declline="227" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1ac59f29dd40385b5b2705299d0366876f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor cytnx::linalg::Cpr</definition>
        <argsstring>(const Tensor &amp;Lt, const T &amp;rc)</argsstring>
        <name>Cpr</name>
        <qualifiedname>cytnx::linalg::Cpr</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Lt</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>rc</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="229" column="12" declfile="include/linalg.hpp" declline="229" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a9cd2be179860bb4742ebe320fa063680" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor cytnx::linalg::Norm</definition>
        <argsstring>(const Tensor &amp;Tl)</argsstring>
        <name>Norm</name>
        <qualifiedname>cytnx::linalg::Norm</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Tl</declname>
        </param>
        <briefdescription>
<para>calculate the norm of a tensor. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>Tl</parametername>
</parameternamelist>
<parameterdescription>
<para>input <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref></para>
</simplesect>
[Note]<orderedlist>
<listitem><para>if the input tensor is rank-1, the frobenius norm is calculated.</para>
</listitem><listitem><para>if the input tensor is rank-N with N&gt;=2, the tensor will be flatten to 1d first, and calculate the frobenius norm. </para>
</listitem></orderedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="243" column="12" declfile="include/linalg.hpp" declline="243" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a5fd73573057cda064a77f69c927a45dc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor cytnx::linalg::Det</definition>
        <argsstring>(const Tensor &amp;Tl)</argsstring>
        <name>Det</name>
        <qualifiedname>cytnx::linalg::Det</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Tl</declname>
        </param>
        <briefdescription>
<para>calculate the determinant of a tensor. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>Tl</parametername>
</parameternamelist>
<parameterdescription>
<para>input <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref></para>
</simplesect>
[Note]<orderedlist>
<listitem><para>input tensor should be a NxN rank-2 <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>. </para>
</listitem></orderedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="255" column="12" declfile="include/linalg.hpp" declline="255" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a516fc9cb6f6f0a53b1f08d3ba51a5262" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &gt;</type>
        <definition>std::vector&lt; Tensor &gt; cytnx::linalg::Svd</definition>
        <argsstring>(const Tensor &amp;Tin, const bool &amp;is_U=true, const bool &amp;is_vT=true)</argsstring>
        <name>Svd</name>
        <qualifiedname>cytnx::linalg::Svd</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Tin</declname>
        </param>
        <param>
          <type>const bool &amp;</type>
          <declname>is_U</declname>
          <defval>true</defval>
        </param>
        <param>
          <type>const bool &amp;</type>
          <declname>is_vT</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Perform Singular-Value decomposition on a rank-2 <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>Tin</parametername>
</parameternamelist>
<parameterdescription>
<para>a <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor </ref>, it should be a rank-2 tensor (matrix) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>is_U</parametername>
</parameternamelist>
<parameterdescription>
<para>if return a left uniform matrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>is_vT</parametername>
</parameternamelist>
<parameterdescription>
<para>if return a right uniform matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>[std::vector&lt;Tensors&gt;] <verbatim>1. the first tensor is a 1-d tensor contanin the singular values
2. the second tensor is the left uniform matrix [U], a 2-d tensor (matrix). It only return
</verbatim> when is_U=true.<orderedlist>
<listitem><para>the third tensor is the right uniform matrix [vT], a 2-d tensor (matrix). It only return when is_vT=true. </para>
</listitem></orderedlist>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="272" column="17" declfile="include/linalg.hpp" declline="272" declcolumn="17"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1ad223439e744e2f3627173d04a873dbf1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &gt;</type>
        <definition>std::vector&lt; Tensor &gt; cytnx::linalg::Svd_truncate</definition>
        <argsstring>(const Tensor &amp;Tin, const cytnx_uint64 &amp;keepdim, const double &amp;err=0, const bool &amp;is_U=true, const bool &amp;is_vT=true, const bool &amp;return_err=false)</argsstring>
        <name>Svd_truncate</name>
        <qualifiedname>cytnx::linalg::Svd_truncate</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Tin</declname>
        </param>
        <param>
          <type>const <ref refid="namespacecytnx_1a9a7ab808c7cbef775461ccc31eaabeb4" kindref="member">cytnx_uint64</ref> &amp;</type>
          <declname>keepdim</declname>
        </param>
        <param>
          <type>const double &amp;</type>
          <declname>err</declname>
          <defval>0</defval>
        </param>
        <param>
          <type>const bool &amp;</type>
          <declname>is_U</declname>
          <defval>true</defval>
        </param>
        <param>
          <type>const bool &amp;</type>
          <declname>is_vT</declname>
          <defval>true</defval>
        </param>
        <param>
          <type>const bool &amp;</type>
          <declname>return_err</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="276" column="17" declfile="include/linalg.hpp" declline="276" declcolumn="17"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a6c3142f633f9aca2f80bb359b9c58cf5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &gt;</type>
        <definition>std::vector&lt; Tensor &gt; cytnx::linalg::Hosvd</definition>
        <argsstring>(const Tensor &amp;Tin, const std::vector&lt; cytnx_uint64 &gt; &amp;mode, const bool &amp;is_core=true, const bool &amp;is_Ls=false, const std::vector&lt; cytnx_int64 &gt; &amp;trucate_dim=std::vector&lt; cytnx_int64 &gt;())</argsstring>
        <name>Hosvd</name>
        <qualifiedname>cytnx::linalg::Hosvd</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Tin</declname>
        </param>
        <param>
          <type>const std::vector&lt; <ref refid="namespacecytnx_1a9a7ab808c7cbef775461ccc31eaabeb4" kindref="member">cytnx_uint64</ref> &gt; &amp;</type>
          <declname>mode</declname>
        </param>
        <param>
          <type>const bool &amp;</type>
          <declname>is_core</declname>
          <defval>true</defval>
        </param>
        <param>
          <type>const bool &amp;</type>
          <declname>is_Ls</declname>
          <defval>false</defval>
        </param>
        <param>
          <type>const std::vector&lt; <ref refid="namespacecytnx_1aa7b7ff4d6d244994d35853a6ce547587" kindref="member">cytnx_int64</ref> &gt; &amp;</type>
          <declname>trucate_dim</declname>
          <defval>std::vector&lt; <ref refid="namespacecytnx_1aa7b7ff4d6d244994d35853a6ce547587" kindref="member">cytnx_int64</ref> &gt;()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="281" column="17" declfile="include/linalg.hpp" declline="281" declcolumn="17"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1af22616b7e35f13b775f2423d19e9ffe7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &gt;</type>
        <definition>std::vector&lt; Tensor &gt; cytnx::linalg::Qr</definition>
        <argsstring>(const Tensor &amp;Tin, const bool &amp;is_tau=false)</argsstring>
        <name>Qr</name>
        <qualifiedname>cytnx::linalg::Qr</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Tin</declname>
        </param>
        <param>
          <type>const bool &amp;</type>
          <declname>is_tau</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>Perform QR decomposition on a rank-2 <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>Tin</parametername>
</parameternamelist>
<parameterdescription>
<para>a <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor </ref>, it should be a rank-2 tensor (matrix) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>is_tau</parametername>
</parameternamelist>
<parameterdescription>
<para>if return the tau that contains the Householder reflectors that generate q along with r. The tau array contains scaling factors for the reflectors </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>[std::vector&lt;Tensors&gt;] <verbatim>1. the first tensor is the orthomormal matrix [Q], a 2-d tensor (matrix)
2. the second tensor is the right-upper triangular matrix [R], a 2-d tensor (matrix).
3. the third tensor is the Householder reflectors [H], a 1-d tensor (vector). It only return
</verbatim> when is_tau=true. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="300" column="17" declfile="include/linalg.hpp" declline="300" declcolumn="17"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a49f6c1a406ac0a3446ea8c9423587dd8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &gt;</type>
        <definition>std::vector&lt; Tensor &gt; cytnx::linalg::Qdr</definition>
        <argsstring>(const Tensor &amp;Tin, const bool &amp;is_tau=false)</argsstring>
        <name>Qdr</name>
        <qualifiedname>cytnx::linalg::Qdr</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Tin</declname>
        </param>
        <param>
          <type>const bool &amp;</type>
          <declname>is_tau</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>Perform QDR decomposition on a rank-2 <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>Tin</parametername>
</parameternamelist>
<parameterdescription>
<para>a <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor </ref>, it should be a rank-2 tensor (matrix) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>is_tau</parametername>
</parameternamelist>
<parameterdescription>
<para>if return the tau that contains the Householder reflectors that generate q along with r. The tau array contains scaling factors for the reflectors </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>[std::vector&lt;Tensors&gt;] <verbatim>1. the first tensor is the orthomormal matrix [Q], a 2-d tensor (matrix)
2. the second tensor is the diagonal matrix [D], a 1-d tensor (matrix).
3. the third tensor is the right-upper triangular matrix [R], a 2-d tensor (matrix).
4. the forth tensor is the Householder reflectors [H], a 1-d tensor (matrix). It only return
</verbatim> when is_tau=true. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="317" column="17" declfile="include/linalg.hpp" declline="317" declcolumn="17"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a63fb9c9751ff27d22f84a52a876cc6fc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &gt;</type>
        <definition>std::vector&lt; Tensor &gt; cytnx::linalg::Eigh</definition>
        <argsstring>(const Tensor &amp;Tin, const bool &amp;is_V=true, const bool &amp;row_v=false)</argsstring>
        <name>Eigh</name>
        <qualifiedname>cytnx::linalg::Eigh</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Tin</declname>
        </param>
        <param>
          <type>const bool &amp;</type>
          <declname>is_V</declname>
          <defval>true</defval>
        </param>
        <param>
          <type>const bool &amp;</type>
          <declname>row_v</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>eigen-value decomposition for Hermitian matrix </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>Tin</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>is_V</parametername>
</parameternamelist>
<parameterdescription>
<para>return eigen vectors </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>row_V</parametername>
</parameternamelist>
<parameterdescription>
<para>if set to ture, the return eigen vectors will be row form. [Note] the Tin should be a rank-2 <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="328" column="17" declfile="include/linalg.hpp" declline="328" declcolumn="17"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a243ceac5dc7d4a8c983b0e7693b97489" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &gt;</type>
        <definition>std::vector&lt; Tensor &gt; cytnx::linalg::Eig</definition>
        <argsstring>(const Tensor &amp;Tin, const bool &amp;is_V=true, const bool &amp;row_v=false)</argsstring>
        <name>Eig</name>
        <qualifiedname>cytnx::linalg::Eig</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Tin</declname>
        </param>
        <param>
          <type>const bool &amp;</type>
          <declname>is_V</declname>
          <defval>true</defval>
        </param>
        <param>
          <type>const bool &amp;</type>
          <declname>row_v</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>eigen-value decomposition for generic square matrix </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>Tin</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>is_V</parametername>
</parameternamelist>
<parameterdescription>
<para>return eigen vectors </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>row_V</parametername>
</parameternamelist>
<parameterdescription>
<para>if set to ture, the return eigen vectors will be row form.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
[Note] the Tin should be a rank-2 <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="340" column="17" declfile="include/linalg.hpp" declline="340" declcolumn="17"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a02d7105bf16d23128687ba92fb231b54" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor cytnx::linalg::Trace</definition>
        <argsstring>(const Tensor &amp;Tn, const cytnx_uint64 &amp;axisA=0, const cytnx_uint64 &amp;axisB=1)</argsstring>
        <name>Trace</name>
        <qualifiedname>cytnx::linalg::Trace</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Tn</declname>
        </param>
        <param>
          <type>const <ref refid="namespacecytnx_1a9a7ab808c7cbef775461ccc31eaabeb4" kindref="member">cytnx_uint64</ref> &amp;</type>
          <declname>axisA</declname>
          <defval>0</defval>
        </param>
        <param>
          <type>const <ref refid="namespacecytnx_1a9a7ab808c7cbef775461ccc31eaabeb4" kindref="member">cytnx_uint64</ref> &amp;</type>
          <declname>axisB</declname>
          <defval>1</defval>
        </param>
        <briefdescription>
<para>perform trace over index. </para>
        </briefdescription>
        <detaileddescription>
<para>[Note] the Tn should be at-least rank-2 <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="349" column="12" declfile="include/linalg.hpp" declline="349" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a25b5f2fdfb550aabc9cc41daa963e1fb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor cytnx::linalg::Min</definition>
        <argsstring>(const Tensor &amp;Tn)</argsstring>
        <name>Min</name>
        <qualifiedname>cytnx::linalg::Min</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Tn</declname>
        </param>
        <briefdescription>
<para>get the minimum element. </para>
        </briefdescription>
        <detaileddescription>
<para>[Note] For complex TN, only real part is compared. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="358" column="12" declfile="include/linalg.hpp" declline="358" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a93ef263824e2dcdab4832ea628959d19" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor cytnx::linalg::Max</definition>
        <argsstring>(const Tensor &amp;Tn)</argsstring>
        <name>Max</name>
        <qualifiedname>cytnx::linalg::Max</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Tn</declname>
        </param>
        <briefdescription>
<para>get the maximum element. </para>
        </briefdescription>
        <detaileddescription>
<para>[Note] For complex TN, only real part is compared. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="367" column="12" declfile="include/linalg.hpp" declline="367" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a24855027b29b1777946617f480bc5014" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor cytnx::linalg::Sum</definition>
        <argsstring>(const Tensor &amp;Tn)</argsstring>
        <name>Sum</name>
        <qualifiedname>cytnx::linalg::Sum</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Tn</declname>
        </param>
        <briefdescription>
<para>get the sum of all the elements. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="375" column="12" declfile="include/linalg.hpp" declline="375" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a53feb441b4b1bd263714ed33e093728f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor cytnx::linalg::Matmul</definition>
        <argsstring>(const Tensor &amp;TL, const Tensor &amp;TR)</argsstring>
        <name>Matmul</name>
        <qualifiedname>cytnx::linalg::Matmul</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>TL</declname>
        </param>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>TR</declname>
        </param>
        <briefdescription>
<para>perform matrix multiplication on two tensors. </para>
        </briefdescription>
        <detaileddescription>
<para>[Note] the TL and TR should be both rank-2 <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="384" column="12" declfile="include/linalg.hpp" declline="384" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1af2e6723dc80031eb28fc10cc19826dda" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor cytnx::linalg::Matmul_dg</definition>
        <argsstring>(const Tensor &amp;Tl, const Tensor &amp;Tr)</argsstring>
        <name>Matmul_dg</name>
        <qualifiedname>cytnx::linalg::Matmul_dg</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Tl</declname>
        </param>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Tr</declname>
        </param>
        <briefdescription>
<para>perform matrix multiplication on two Tensors with one rank-1 and the other rank-2 where the rank-1 represent the diagonal elements of the specific tensor. </para>
        </briefdescription>
        <detaileddescription>
<para>[Note] the TL and TR one of them should be rank-1 <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> and the other should be rank-2 <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="394" column="12" declfile="include/linalg.hpp" declline="394" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1af819d2fc4522d2a6287aa16dfbe3f787" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor cytnx::linalg::InvM</definition>
        <argsstring>(const Tensor &amp;Tin)</argsstring>
        <name>InvM</name>
        <qualifiedname>cytnx::linalg::InvM</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Tin</declname>
        </param>
        <briefdescription>
<para>Matrix inverse. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>[<ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>]</para>
</simplesect>
[Note] the Tin should be a rank-2 <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="405" column="12" declfile="include/linalg.hpp" declline="405" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1ac414e561888051c1fbacde18c9039fbf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void cytnx::linalg::InvM_</definition>
        <argsstring>(Tensor &amp;Tin)</argsstring>
        <name>InvM_</name>
        <qualifiedname>cytnx::linalg::InvM_</qualifiedname>
        <param>
          <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Tin</declname>
        </param>
        <briefdescription>
<para>inplace perform Matrix inverse. </para>
        </briefdescription>
        <detaileddescription>
<para>description: on return, the Tin will be modified to it&apos;s inverse.</para>
<para>[Note] the Tin should be a rank-2 <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="414" column="10" declfile="include/linalg.hpp" declline="414" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a8680f6a91b7110d68c1d9e9a4da700d6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor cytnx::linalg::Inv</definition>
        <argsstring>(const Tensor &amp;Tin, const double &amp;clip)</argsstring>
        <name>Inv</name>
        <qualifiedname>cytnx::linalg::Inv</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Tin</declname>
        </param>
        <param>
          <type>const double &amp;</type>
          <declname>clip</declname>
        </param>
        <briefdescription>
<para>Element-wise inverse with clip. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>[<ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>]</para>
</simplesect>
description: Performs Elementwise inverse with clip. if A[i] &lt; clip, then 1/A[i] = 0 will be set.</para>
<para>[Note] For complex type Tensors, the square norm is used to determine the clip. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="429" column="12" declfile="include/linalg.hpp" declline="429" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1aa664cc05d63056151c826d8457791c5d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void cytnx::linalg::Inv_</definition>
        <argsstring>(Tensor &amp;Tin, const double &amp;clip)</argsstring>
        <name>Inv_</name>
        <qualifiedname>cytnx::linalg::Inv_</qualifiedname>
        <param>
          <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Tin</declname>
        </param>
        <param>
          <type>const double &amp;</type>
          <declname>clip</declname>
        </param>
        <briefdescription>
<para>inplace perform Element-wise inverse with clip. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>[<ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>]</para>
</simplesect>
description:<orderedlist>
<listitem><para>Performs Elementwise inverse with clip. if A[i] &lt; clip, then 1/A[i] = 0 will be set.</para>
</listitem><listitem><para>on return, all the elements will be modified to it&apos;s inverse. if Tin is integer type, it will automatically promote to Type.Double.</para>
</listitem></orderedlist>
</para>
<para>[Note] For complex type Tensors, the square norm is used to determine the clip. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="444" column="10" declfile="include/linalg.hpp" declline="444" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a470d0886432554a35ecaf961451c0806" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor cytnx::linalg::Conj</definition>
        <argsstring>(const Tensor &amp;Tin)</argsstring>
        <name>Conj</name>
        <qualifiedname>cytnx::linalg::Conj</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Tin</declname>
        </param>
        <briefdescription>
<para>Conjugate all the element in <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>[<ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>]</para>
</simplesect>
[Note]<orderedlist>
<listitem><para>if the input <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> is complex, then return a new <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> with all the elements are conjugated.</para>
</listitem><listitem><para>if the input <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> is real, then return a copy of input <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>. </para>
</listitem></orderedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="458" column="12" declfile="include/linalg.hpp" declline="458" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1adc3233bf8bc3eb6a435340f912412801" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void cytnx::linalg::Conj_</definition>
        <argsstring>(Tensor &amp;Tin)</argsstring>
        <name>Conj_</name>
        <qualifiedname>cytnx::linalg::Conj_</qualifiedname>
        <param>
          <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Tin</declname>
        </param>
        <briefdescription>
<para>inplace perform Conjugate on all the element in <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>[Note]<orderedlist>
<listitem><para>if the input <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> is complex, the elements of input <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> will all be conjugated.</para>
</listitem><listitem><para>if the input <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> is real, then nothing act. </para>
</listitem></orderedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="466" column="10" declfile="include/linalg.hpp" declline="466" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1aac38382cbc0e8202411c96a0ff636471" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor cytnx::linalg::Exp</definition>
        <argsstring>(const Tensor &amp;Tin)</argsstring>
        <name>Exp</name>
        <qualifiedname>cytnx::linalg::Exp</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Tin</declname>
        </param>
        <briefdescription>
<para>Exponential all the element in <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>[Double <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>] or [ComplexDouble <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>] </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="476" column="12" declfile="include/linalg.hpp" declline="476" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a5831918722e5d18f4eaf37834b8fbf77" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor cytnx::linalg::Expf</definition>
        <argsstring>(const Tensor &amp;Tin)</argsstring>
        <name>Expf</name>
        <qualifiedname>cytnx::linalg::Expf</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Tin</declname>
        </param>
        <briefdescription>
<para>Exponential all the element in <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>[Float <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>] or [ComplexFloat <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>] </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="484" column="12" declfile="include/linalg.hpp" declline="484" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1aaab08439dde94ee87939d07933ede6e3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void cytnx::linalg::Exp_</definition>
        <argsstring>(Tensor &amp;Tin)</argsstring>
        <name>Exp_</name>
        <qualifiedname>cytnx::linalg::Exp_</qualifiedname>
        <param>
          <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Tin</declname>
        </param>
        <briefdescription>
<para>inplace perform Exponential on all the element in <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>Tin</parametername>
<parametername>the</parametername>
</parameternamelist>
<parameterdescription>
<para>input <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
description:<orderedlist>
<listitem><para>on return, the elements in Tin will be modified to it&apos;s exponetial value.</para>
</listitem><listitem><para>For Real, if the type is not Double, change the type of the input tensor to Double.</para>
</listitem><listitem><para>For Complex, if input is ComplexFloat, promote to ComplexDouble. </para>
</listitem></orderedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="495" column="10" declfile="include/linalg.hpp" declline="495" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a5de1faf71c76cdc6b7fa5ba3a3e21bbb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void cytnx::linalg::Expf_</definition>
        <argsstring>(Tensor &amp;Tin)</argsstring>
        <name>Expf_</name>
        <qualifiedname>cytnx::linalg::Expf_</qualifiedname>
        <param>
          <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Tin</declname>
        </param>
        <briefdescription>
<para>inplace perform Exponential on all the element in <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>Tin</parametername>
<parametername>the</parametername>
</parameternamelist>
<parameterdescription>
<para>input <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
description:<orderedlist>
<listitem><para>on return, the elements in Tin will be modified to it&apos;s exponetial value.</para>
</listitem><listitem><para>For Real, if the type is not Float, change the type of the input tensor to Float.</para>
</listitem><listitem><para>For Complex, if input is ComplexDouble, promote to ComplexFloat. </para>
</listitem></orderedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="506" column="10" declfile="include/linalg.hpp" declline="506" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a2919ef6c163a54360071c286df3fb92e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor cytnx::linalg::Pow</definition>
        <argsstring>(const Tensor &amp;Tin, const double &amp;p)</argsstring>
        <name>Pow</name>
        <qualifiedname>cytnx::linalg::Pow</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Tin</declname>
        </param>
        <param>
          <type>const double &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
<para>take power p on all the elements in <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
<parametername>the</parametername>
</parameternamelist>
<parameterdescription>
<para>power </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>[<ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>] </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="517" column="12" declfile="include/linalg.hpp" declline="517" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a269ef291355dfee4421fa55ad0247aad" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void cytnx::linalg::Pow_</definition>
        <argsstring>(Tensor &amp;Tin, const double &amp;p)</argsstring>
        <name>Pow_</name>
        <qualifiedname>cytnx::linalg::Pow_</qualifiedname>
        <param>
          <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Tin</declname>
        </param>
        <param>
          <type>const double &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
<para>inplace perform power on all the elements in <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>Tin</parametername>
<parametername>the</parametername>
</parameternamelist>
<parameterdescription>
<para>input <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>p</parametername>
<parametername>the</parametername>
</parameternamelist>
<parameterdescription>
<para>power.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
description: on return, the elements in Tin will be modified to it&apos;s exponetial value. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="527" column="10" declfile="include/linalg.hpp" declline="527" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a3ded6435c7b47eb348d03783bfe72611" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor cytnx::linalg::Abs</definition>
        <argsstring>(const Tensor &amp;Tin)</argsstring>
        <name>Abs</name>
        <qualifiedname>cytnx::linalg::Abs</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Tin</declname>
        </param>
        <briefdescription>
<para>Elementwise absolute value. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>Tin</parametername>
</parameternamelist>
<parameterdescription>
<para>tensor. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>[<ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>] </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="538" column="12" declfile="include/linalg.hpp" declline="538" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a30687e6240a889c04637b33ef90c2525" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void cytnx::linalg::Abs_</definition>
        <argsstring>(Tensor &amp;Tin)</argsstring>
        <name>Abs_</name>
        <qualifiedname>cytnx::linalg::Abs_</qualifiedname>
        <param>
          <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Tin</declname>
        </param>
        <briefdescription>
<para>inplace perform elementwiase absolute value. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>Tin</parametername>
<parametername>the</parametername>
</parameternamelist>
<parameterdescription>
<para>input <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
description: on return, the elements in Tin will be modified to it&apos;s absolute value. Note that if the input tensor is complex, it will be modified to real type. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="548" column="10" declfile="include/linalg.hpp" declline="548" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a5913f0bdd6cc130aeb927f42a874a149" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor cytnx::linalg::Diag</definition>
        <argsstring>(const Tensor &amp;Tin)</argsstring>
        <name>Diag</name>
        <qualifiedname>cytnx::linalg::Diag</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Tin</declname>
        </param>
        <briefdescription>
<para>return a diagonal tensor with diagonal elements provided as Tin. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>[<ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>]</para>
</simplesect>
description: the return <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> will be rank-2, with shape=(L, L); where L is the number of elements in Tin.</para>
<para>[Note] Tin should be a rank-1 <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="565" column="12" declfile="include/linalg.hpp" declline="565" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a242f1b9c1ee7938ba050121773ab4b55" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor cytnx::linalg::Tensordot</definition>
        <argsstring>(const Tensor &amp;Tl, const Tensor &amp;Tr, const std::vector&lt; cytnx_uint64 &gt; &amp;idxl, const std::vector&lt; cytnx_uint64 &gt; &amp;idxr, const bool &amp;cacheL=false, const bool &amp;cacheR=false)</argsstring>
        <name>Tensordot</name>
        <qualifiedname>cytnx::linalg::Tensordot</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Tl</declname>
        </param>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Tr</declname>
        </param>
        <param>
          <type>const std::vector&lt; <ref refid="namespacecytnx_1a9a7ab808c7cbef775461ccc31eaabeb4" kindref="member">cytnx_uint64</ref> &gt; &amp;</type>
          <declname>idxl</declname>
        </param>
        <param>
          <type>const std::vector&lt; <ref refid="namespacecytnx_1a9a7ab808c7cbef775461ccc31eaabeb4" kindref="member">cytnx_uint64</ref> &gt; &amp;</type>
          <declname>idxr</declname>
        </param>
        <param>
          <type>const bool &amp;</type>
          <declname>cacheL</declname>
          <defval>false</defval>
        </param>
        <param>
          <type>const bool &amp;</type>
          <declname>cacheR</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>perform tensor dot by sum out the indices assigned of two Tensors. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>Tl</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> #1 </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Tr</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> #2 </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>idxl</parametername>
</parameternamelist>
<parameterdescription>
<para>the indices of rank of <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> #1 that is going to sum with <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> #2 </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>idxr</parametername>
</parameternamelist>
<parameterdescription>
<para>the indices of rank of <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> #2 that is going to sum with <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> #1 </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cacheL</parametername>
</parameternamelist>
<parameterdescription>
<para>cache <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> #1 (See user-guide for details) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cacheR</parametername>
</parameternamelist>
<parameterdescription>
<para>cache <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> #2 (See user-guide for details) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>[<ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>]</para>
</simplesect>
[Note]<orderedlist>
<listitem><para>the elements in idxl and idxr have one to one correspondence.</para>
</listitem><listitem><para>two tensors should on same device. </para>
</listitem></orderedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="584" column="12" declfile="include/linalg.hpp" declline="584" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1ac77faf8e0c0153e1890610a6e21f36af" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor cytnx::linalg::Tensordot_dg</definition>
        <argsstring>(const Tensor &amp;Tl, const Tensor &amp;Tr, const std::vector&lt; cytnx_uint64 &gt; &amp;idxl, const std::vector&lt; cytnx_uint64 &gt; &amp;idxr, const bool &amp;diag_L)</argsstring>
        <name>Tensordot_dg</name>
        <qualifiedname>cytnx::linalg::Tensordot_dg</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Tl</declname>
        </param>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Tr</declname>
        </param>
        <param>
          <type>const std::vector&lt; <ref refid="namespacecytnx_1a9a7ab808c7cbef775461ccc31eaabeb4" kindref="member">cytnx_uint64</ref> &gt; &amp;</type>
          <declname>idxl</declname>
        </param>
        <param>
          <type>const std::vector&lt; <ref refid="namespacecytnx_1a9a7ab808c7cbef775461ccc31eaabeb4" kindref="member">cytnx_uint64</ref> &gt; &amp;</type>
          <declname>idxr</declname>
        </param>
        <param>
          <type>const bool &amp;</type>
          <declname>diag_L</declname>
        </param>
        <briefdescription>
<para>perform tensor dot by sum out the indices assigned of two Tensors, with either one of them to be a rank-2 diagonal tensor represented by a rank-2 tensor. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>Tl</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> #1 </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Tr</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> #2 </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>idxl</parametername>
</parameternamelist>
<parameterdescription>
<para>the indices of rank of <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> #1 that is going to sum with <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> #2 </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>idxr</parametername>
</parameternamelist>
<parameterdescription>
<para>the indices of rank of <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> #2 that is going to sum with <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> #1 </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>diag_L</parametername>
</parameternamelist>
<parameterdescription>
<para>if Tl(true)/Tr(false) is a diagnal matrix, represented by a rank-1 tensor. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>[<ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>]</para>
</simplesect>
[Note]<orderedlist>
<listitem><para>the elements in idxl and idxr have one to one correspondence.</para>
</listitem><listitem><para>two tensors should on same device.</para>
</listitem><listitem><para>if diag_L=true, Tl should be a rank-1 tensor as the diagonal elements of a diagonal matrix. if false, Tr should be a rank-1 tensor </para>
</listitem></orderedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="607" column="12" declfile="include/linalg.hpp" declline="607" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a3e8edc89fdabb9c0f9b342198a31798b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor cytnx::linalg::Outer</definition>
        <argsstring>(const Tensor &amp;Tl, const Tensor &amp;Tr)</argsstring>
        <name>Outer</name>
        <qualifiedname>cytnx::linalg::Outer</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Tl</declname>
        </param>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Tr</declname>
        </param>
        <briefdescription>
<para>perform outer produces of two rank-1 <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>Tl</parametername>
</parameternamelist>
<parameterdescription>
<para>rank-1 <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> #1 </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Tr</parametername>
</parameternamelist>
<parameterdescription>
<para>rank-1 <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> #2 </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>[<ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>]</para>
</simplesect>
description: if the <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> #1 has [shape_1], and <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> #2 has [shape_2]; then the return <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> will have shape: concate(shape_1,shape_2)</para>
<para>[Note] two tensor should on same device. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="627" column="12" declfile="include/linalg.hpp" declline="627" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1abc22428de7f69d2afc9a27fca76bfe15" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor cytnx::linalg::Kron</definition>
        <argsstring>(const Tensor &amp;Tl, const Tensor &amp;Tr, const bool &amp;Tl_pad_left=false, const bool &amp;Tr_pad_left=false)</argsstring>
        <name>Kron</name>
        <qualifiedname>cytnx::linalg::Kron</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Tl</declname>
        </param>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Tr</declname>
        </param>
        <param>
          <type>const bool &amp;</type>
          <declname>Tl_pad_left</declname>
          <defval>false</defval>
        </param>
        <param>
          <type>const bool &amp;</type>
          <declname>Tr_pad_left</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>perform kronecker produces of two <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>Tl</parametername>
</parameternamelist>
<parameterdescription>
<para>rank-n <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> #1 </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Tr</parametername>
</parameternamelist>
<parameterdescription>
<para>rank-m <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> #2 </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Tl_pad_left</parametername>
</parameternamelist>
<parameterdescription>
<para>The padding scheme for Tl if Tl.rank != Tr.rank </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Tr_pad_left</parametername>
</parameternamelist>
<parameterdescription>
<para>The padding scheme for Tr if Tl.rank != Tr.rank </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>[<ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>]</para>
</simplesect>
description: The function assume two tensor has the same rank. In case where two tensors have different ranks, the small one will be extend by adding redundant dimension to the beginning of axis (T&lt;x&gt;_pad_right=true) or by adding redundant dim to the last axis (if T&lt;x&gt;_pad_left=false [default]). if the <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> #1 has shape=(i1,j1,k1,l1...), and <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> #2 has shape=(i2,j2,k2,l2...); then the return <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> will have shape=(i1*i2,j1*j2,k1*k2...)</para>
<para>[Note] two tensor should on same device. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="651" column="12" declfile="include/linalg.hpp" declline="651" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1ac908296e4737c2b080669faf26b89253" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor cytnx::linalg::Directsum</definition>
        <argsstring>(const Tensor &amp;T1, const Tensor &amp;T2, const std::vector&lt; cytnx_uint64 &gt; &amp;shared_axes)</argsstring>
        <name>Directsum</name>
        <qualifiedname>cytnx::linalg::Directsum</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>T1</declname>
        </param>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>T2</declname>
        </param>
        <param>
          <type>const std::vector&lt; <ref refid="namespacecytnx_1a9a7ab808c7cbef775461ccc31eaabeb4" kindref="member">cytnx_uint64</ref> &gt; &amp;</type>
          <declname>shared_axes</declname>
        </param>
        <briefdescription>
<para>perform directsum of two <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>T1</parametername>
</parameternamelist>
<parameterdescription>
<para>rank-n <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> #1 </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T2</parametername>
</parameternamelist>
<parameterdescription>
<para>rank-n <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> #2 </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>shared_axes</parametername>
</parameternamelist>
<parameterdescription>
<para>The axes that are shared by two tensors </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>[<ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>]</para>
</simplesect>
description: The function assume two tensor has the same rank, and axes indicated in &lt;shared_axes&gt; are the same for both T1 and T2. The out put tensors will have same rank as T1 and T2, with the dimension of rest of the axes being the sum of dimensions of T1 and T2. e.g., the out put shape = (i1+i2,j1+j2, share_axis_1, k1+k2, share_axis_2, ...); where T1.shape = (i1,j1,share_axis_1,k1,share_axis_2 ...) and T2.shape = (i2,j2,share_axis_1,k2,share_axis_2 ...)</para>
<para>[Note] two tensor should on same device. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="676" column="12" declfile="include/linalg.hpp" declline="676" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1aa69a91a5651fce55380cf800c6030d73" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor cytnx::linalg::Vectordot</definition>
        <argsstring>(const Tensor &amp;Tl, const Tensor &amp;Tr, const bool &amp;is_conj=false)</argsstring>
        <name>Vectordot</name>
        <qualifiedname>cytnx::linalg::Vectordot</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Tl</declname>
        </param>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Tr</declname>
        </param>
        <param>
          <type>const bool &amp;</type>
          <declname>is_conj</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>perform inner product of vectors </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>Tl</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> #1 </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Tr</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> #2 </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>if</parametername>
</parameternamelist>
<parameterdescription>
<para>the Tl should be conjugated (only work for complex. For real <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>, no function), default: false </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>[<ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>] Rank-0</para>
</simplesect>
description: two Tensors must be Rank-1, with same length.</para>
<para>[Note] performance tune: This function have better performance when two vectors with same types, and are one of following type: cytnx_double, cytnx_float, cytnx_complex64 or cytnx_complex128. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="700" column="12" declfile="include/linalg.hpp" declline="700" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a215dbfd2aa7ef898450de7afff726bca" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor cytnx::linalg::Dot</definition>
        <argsstring>(const Tensor &amp;Tl, const Tensor &amp;Tr)</argsstring>
        <name>Dot</name>
        <qualifiedname>cytnx::linalg::Dot</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Tl</declname>
        </param>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Tr</declname>
        </param>
        <briefdescription>
<para>dot product of two arrays. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>Tl</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> #1 </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Tr</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> #2 </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>[<ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>]</para>
</simplesect>
description:<orderedlist>
<listitem><para>if both Tl and Tr are 1d arrays, it is inner product of vectors (no complex conj), it calls <ref refid="namespacecytnx_1_1linalg_1aa69a91a5651fce55380cf800c6030d73" kindref="member">linalg.Vectordot</ref> with is_conj=false.</para>
</listitem><listitem><para>if both Tl and Tr are 2d arrays, it calls <ref refid="namespacecytnx_1_1linalg_1a53feb441b4b1bd263714ed33e093728f" kindref="member">linalg.Matmul</ref> to compute the matrix multiplication</para>
</listitem><listitem><para>if Tl is Nd array (with N&gt;=2, and Tr is 1-D array, it is sum product over the last axis of a with b</para>
</listitem></orderedlist>
</para>
<para>[Note] performance tune: This function have better performance when two arrays with same types, and are one of following type: cytnx_double, cytnx_float, cytnx_complex64 or cytnx_complex128.</para>
<para>[Python] In Python API, operator@ is overloaded as a shorthand of <ref refid="namespacecytnx_1_1linalg_1a215dbfd2aa7ef898450de7afff726bca" kindref="member">linalg::Dot</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="726" column="12" declfile="include/linalg.hpp" declline="726" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a5a502c7d0a6a46f0e695f211a42ab9dc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &gt;</type>
        <definition>std::vector&lt; Tensor &gt; cytnx::linalg::Tridiag</definition>
        <argsstring>(const Tensor &amp;Diag, const Tensor &amp;Sub_diag, const bool &amp;is_V=true, const bool &amp;is_row=false, bool throw_excp=false)</argsstring>
        <name>Tridiag</name>
        <qualifiedname>cytnx::linalg::Tridiag</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Diag</declname>
        </param>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Sub_diag</declname>
        </param>
        <param>
          <type>const bool &amp;</type>
          <declname>is_V</declname>
          <defval>true</defval>
        </param>
        <param>
          <type>const bool &amp;</type>
          <declname>is_row</declname>
          <defval>false</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>throw_excp</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>perform diagonalization of symmetric tri-diagnoal matrix. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>Diag</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> #1 </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Sub_diag</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> #2 </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>is_V</parametername>
</parameternamelist>
<parameterdescription>
<para>if calculate the eigen value. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>k</parametername>
</parameternamelist>
<parameterdescription>
<para>Return k lowest eigen vector if is_V=True </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>throw_excp</parametername>
</parameternamelist>
<parameterdescription>
<para>Whether to throw exception when error occurs in Tridiag internal function </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>[vector&lt;Tensor&gt;] if is_V = True, the first tensor is the eigen value, and second tensor is eigenvector of shape [k,L].</para>
</simplesect>
description: two Tensors must be Rank-1, with length of Diag = L and Sub_diag length = L-1.</para>
<para>[Note] performance tune: This function have better performance when two vectors with same types, and are one of following type: cytnx_double, cytnx_float. In general all real type can be use as input, which will be promote to floating point type for calculation. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="750" column="17" declfile="include/linalg.hpp" declline="750" declcolumn="17"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1af116da0421730edbcba17cda953f13b6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor cytnx::linalg::ExpH</definition>
        <argsstring>(const Tensor &amp;in, const T &amp;a, const T &amp;b=0)</argsstring>
        <name>ExpH</name>
        <qualifiedname>cytnx::linalg::ExpH</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>in</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>b</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>perform matrix exponential for Hermitian matrix </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>in</parametername>
</parameternamelist>
<parameterdescription>
<para>input <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>, should be Hermitian </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>rescale factor </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>bias </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>[<ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>]</para>
</simplesect>
description: perform matrix exponential with <formula id="0">$O = \exp{aM + b}$</formula>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="768" column="12" declfile="include/linalg.hpp" declline="768" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1ae1c7e52ab3ee393428ff6fb4f087425c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor cytnx::linalg::ExpH</definition>
        <argsstring>(const Tensor &amp;in)</argsstring>
        <name>ExpH</name>
        <qualifiedname>cytnx::linalg::ExpH</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>in</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="769" column="12" declfile="include/linalg.hpp" declline="769" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a0d4b1c10f01b98fd738af6ac3abd7021" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor cytnx::linalg::ExpM</definition>
        <argsstring>(const Tensor &amp;in, const T &amp;a, const T &amp;b=0)</argsstring>
        <name>ExpM</name>
        <qualifiedname>cytnx::linalg::ExpM</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>in</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>b</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>perform matrix exponential for generic matrix </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>in</parametername>
</parameternamelist>
<parameterdescription>
<para>input <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>, should be a square rank-2. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>rescale factor </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>bias </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>[<ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>]</para>
</simplesect>
description: perform matrix exponential with <formula id="0">$O = \exp{aM + b}$</formula>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="788" column="12" declfile="include/linalg.hpp" declline="788" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a07b223a17f1b1daa8de5ad1e9dc1dd34" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor cytnx::linalg::ExpM</definition>
        <argsstring>(const Tensor &amp;in)</argsstring>
        <name>ExpM</name>
        <qualifiedname>cytnx::linalg::ExpM</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>in</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="790" column="12" declfile="include/linalg.hpp" declline="790" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a91b798c44c9479338b03e13f73284b3f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &gt;</type>
        <definition>std::vector&lt; Tensor &gt; cytnx::linalg::Lanczos</definition>
        <argsstring>(LinOp *Hop, const Tensor &amp;Tin=Tensor(), const std::string method=&quot;Gnd&quot;, const double &amp;CvgCrit=1.0e-14, const unsigned int &amp;Maxiter=10000, const cytnx_uint64 &amp;k=1, const bool &amp;is_V=true, const bool &amp;is_row=false, const cytnx_uint32 &amp;max_krydim=0, const bool &amp;verbose=false)</argsstring>
        <name>Lanczos</name>
        <qualifiedname>cytnx::linalg::Lanczos</qualifiedname>
        <param>
          <type><ref refid="classcytnx_1_1LinOp" kindref="compound">LinOp</ref> *</type>
          <declname>Hop</declname>
        </param>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Tin</declname>
          <defval><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>()</defval>
        </param>
        <param>
          <type>const std::string</type>
          <declname>method</declname>
          <defval>&quot;Gnd&quot;</defval>
        </param>
        <param>
          <type>const double &amp;</type>
          <declname>CvgCrit</declname>
          <defval>1.0e-14</defval>
        </param>
        <param>
          <type>const unsigned int &amp;</type>
          <declname>Maxiter</declname>
          <defval>10000</defval>
        </param>
        <param>
          <type>const <ref refid="namespacecytnx_1a9a7ab808c7cbef775461ccc31eaabeb4" kindref="member">cytnx_uint64</ref> &amp;</type>
          <declname>k</declname>
          <defval>1</defval>
        </param>
        <param>
          <type>const bool &amp;</type>
          <declname>is_V</declname>
          <defval>true</defval>
        </param>
        <param>
          <type>const bool &amp;</type>
          <declname>is_row</declname>
          <defval>false</defval>
        </param>
        <param>
          <type>const <ref refid="namespacecytnx_1a335d8fee19dee02206dbecec6e5ec610" kindref="member">cytnx_uint32</ref> &amp;</type>
          <declname>max_krydim</declname>
          <defval>0</defval>
        </param>
        <param>
          <type>const bool &amp;</type>
          <declname>verbose</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>perform Lanczos for hermitian/symmetric matrices or linear function. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>Hop</parametername>
</parameternamelist>
<parameterdescription>
<para>the Linear Operator defined by <ref refid="classcytnx_1_1LinOp" kindref="compound">LinOp</ref> class or it&apos;s inheritance (see <ref refid="classcytnx_1_1LinOp" kindref="compound">LinOp</ref>). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Tin</parametername>
</parameternamelist>
<parameterdescription>
<para>the initial vector, this should be rank-1. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>method</parametername>
</parameternamelist>
<parameterdescription>
<para>the desired Lanczos method to use, can be &apos;ER&apos; or &apos;Gnd&apos;. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>CvgCrit</parametername>
</parameternamelist>
<parameterdescription>
<para>the convergence criterion of the energy. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>maxiter</parametername>
</parameternamelist>
<parameterdescription>
<para>the maximum interation steps for each k. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>k</parametername>
</parameternamelist>
<parameterdescription>
<para>the number of lowest k eigen values. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>is_V</parametername>
</parameternamelist>
<parameterdescription>
<para>if set to true, the eigen vectors will be returned. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>is_row</parametername>
</parameternamelist>
<parameterdescription>
<para>whether the return eigen vectors should be in row-major form. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>max_krydim</parametername>
</parameternamelist>
<parameterdescription>
<para>the maximum krylov subspace dimension for each iteration. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>verbose</parametername>
</parameternamelist>
<parameterdescription>
<para>print out iteration info. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>[eigvals (<ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>), eigvecs (<ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>)(option)] #description: This function calculate the eigen value problem using explicitly restarted Lanczos. #Performance tune: For small linear dimension, try to reduce max_krydim. #[Note] To use, define a linear operator with <ref refid="classcytnx_1_1LinOp" kindref="compound">LinOp</ref> class either by assign a custom function or create a class that inherit <ref refid="classcytnx_1_1LinOp" kindref="compound">LinOp</ref> (see <ref refid="classcytnx_1_1LinOp" kindref="compound">LinOp</ref> for further details) </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="816" column="17" declfile="include/linalg.hpp" declline="816" declcolumn="17"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a7518c86cddfc48a2848d79e4dc6e8d14" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; <ref refid="classcytnx_1_1UniTensor" kindref="compound">UniTensor</ref> &gt;</type>
        <definition>std::vector&lt; UniTensor &gt; cytnx::linalg::Lanczos</definition>
        <argsstring>(LinOp *Hop, const UniTensor &amp;Tin=UniTensor(), const std::string method=&quot;Gnd&quot;, const double &amp;CvgCrit=1.0e-14, const unsigned int &amp;Maxiter=10000, const cytnx_uint64 &amp;k=1, const bool &amp;is_V=true, const bool &amp;is_row=false, const cytnx_uint32 &amp;max_krydim=4, const bool &amp;verbose=false)</argsstring>
        <name>Lanczos</name>
        <qualifiedname>cytnx::linalg::Lanczos</qualifiedname>
        <param>
          <type><ref refid="classcytnx_1_1LinOp" kindref="compound">LinOp</ref> *</type>
          <declname>Hop</declname>
        </param>
        <param>
          <type>const <ref refid="classcytnx_1_1UniTensor" kindref="compound">UniTensor</ref> &amp;</type>
          <declname>Tin</declname>
          <defval><ref refid="classcytnx_1_1UniTensor" kindref="compound">UniTensor</ref>()</defval>
        </param>
        <param>
          <type>const std::string</type>
          <declname>method</declname>
          <defval>&quot;Gnd&quot;</defval>
        </param>
        <param>
          <type>const double &amp;</type>
          <declname>CvgCrit</declname>
          <defval>1.0e-14</defval>
        </param>
        <param>
          <type>const unsigned int &amp;</type>
          <declname>Maxiter</declname>
          <defval>10000</defval>
        </param>
        <param>
          <type>const <ref refid="namespacecytnx_1a9a7ab808c7cbef775461ccc31eaabeb4" kindref="member">cytnx_uint64</ref> &amp;</type>
          <declname>k</declname>
          <defval>1</defval>
        </param>
        <param>
          <type>const bool &amp;</type>
          <declname>is_V</declname>
          <defval>true</defval>
        </param>
        <param>
          <type>const bool &amp;</type>
          <declname>is_row</declname>
          <defval>false</defval>
        </param>
        <param>
          <type>const <ref refid="namespacecytnx_1a335d8fee19dee02206dbecec6e5ec610" kindref="member">cytnx_uint32</ref> &amp;</type>
          <declname>max_krydim</declname>
          <defval>4</defval>
        </param>
        <param>
          <type>const bool &amp;</type>
          <declname>verbose</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>perform Lanczos for hermitian/symmetric matrices or linear function. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>Hop</parametername>
</parameternamelist>
<parameterdescription>
<para>the Linear Operator defined by <ref refid="classcytnx_1_1LinOp" kindref="compound">LinOp</ref> class or it&apos;s inheritance (see <ref refid="classcytnx_1_1LinOp" kindref="compound">LinOp</ref>). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Tin</parametername>
</parameternamelist>
<parameterdescription>
<para>the initial vector, this should be a <ref refid="classcytnx_1_1UniTensor" kindref="compound">UniTensor</ref>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>method</parametername>
</parameternamelist>
<parameterdescription>
<para>the desired Lanczos method to use, can be &apos;ER&apos; or &apos;Gnd&apos;. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>CvgCrit</parametername>
</parameternamelist>
<parameterdescription>
<para>the convergence criterion of the energy. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>maxiter</parametername>
</parameternamelist>
<parameterdescription>
<para>the maximum interation steps for each k. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>k</parametername>
</parameternamelist>
<parameterdescription>
<para>the number of lowest k eigen values. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>is_V</parametername>
</parameternamelist>
<parameterdescription>
<para>if set to true, the eigen vectors will be returned. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>is_row</parametername>
</parameternamelist>
<parameterdescription>
<para>whether the return eigen vectors should be in row-major form. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>max_krydim</parametername>
</parameternamelist>
<parameterdescription>
<para>the maximum krylov subspace dimension for each iteration. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>verbose</parametername>
</parameternamelist>
<parameterdescription>
<para>print out iteration info. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>[eigvals (<ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>), eigvecs (<ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>)(option)] #description: This function calculate the eigen value problem using explicitly restarted Lanczos. #Performance tune: For small linear dimension, try to reduce max_krydim. #[Note] To use, define a linear operator with <ref refid="classcytnx_1_1LinOp" kindref="compound">LinOp</ref> class either by assign a custom function or create a class that inherit <ref refid="classcytnx_1_1LinOp" kindref="compound">LinOp</ref> (see <ref refid="classcytnx_1_1LinOp" kindref="compound">LinOp</ref> for further details) </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="846" column="17" declfile="include/linalg.hpp" declline="846" declcolumn="17"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1abf13b4960e1c68f717840de7e555f1f0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &gt;</type>
        <definition>std::vector&lt; Tensor &gt; cytnx::linalg::Lanczos_ER</definition>
        <argsstring>(LinOp *Hop, const cytnx_uint64 &amp;k=1, const bool &amp;is_V=true, const cytnx_uint64 &amp;maxiter=10000, const double &amp;CvgCrit=1.0e-14, const bool &amp;is_row=false, const Tensor &amp;Tin=Tensor(), const cytnx_uint32 &amp;max_krydim=4, const bool &amp;verbose=false)</argsstring>
        <name>Lanczos_ER</name>
        <qualifiedname>cytnx::linalg::Lanczos_ER</qualifiedname>
        <param>
          <type><ref refid="classcytnx_1_1LinOp" kindref="compound">LinOp</ref> *</type>
          <declname>Hop</declname>
        </param>
        <param>
          <type>const <ref refid="namespacecytnx_1a9a7ab808c7cbef775461ccc31eaabeb4" kindref="member">cytnx_uint64</ref> &amp;</type>
          <declname>k</declname>
          <defval>1</defval>
        </param>
        <param>
          <type>const bool &amp;</type>
          <declname>is_V</declname>
          <defval>true</defval>
        </param>
        <param>
          <type>const <ref refid="namespacecytnx_1a9a7ab808c7cbef775461ccc31eaabeb4" kindref="member">cytnx_uint64</ref> &amp;</type>
          <declname>maxiter</declname>
          <defval>10000</defval>
        </param>
        <param>
          <type>const double &amp;</type>
          <declname>CvgCrit</declname>
          <defval>1.0e-14</defval>
        </param>
        <param>
          <type>const bool &amp;</type>
          <declname>is_row</declname>
          <defval>false</defval>
        </param>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Tin</declname>
          <defval><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>()</defval>
        </param>
        <param>
          <type>const <ref refid="namespacecytnx_1a335d8fee19dee02206dbecec6e5ec610" kindref="member">cytnx_uint32</ref> &amp;</type>
          <declname>max_krydim</declname>
          <defval>4</defval>
        </param>
        <param>
          <type>const bool &amp;</type>
          <declname>verbose</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>perform Lanczos for hermitian/symmetric matrices or linear function. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>Hop</parametername>
</parameternamelist>
<parameterdescription>
<para>the Linear Operator defined by <ref refid="classcytnx_1_1LinOp" kindref="compound">LinOp</ref> class or it&apos;s inheritance (see <ref refid="classcytnx_1_1LinOp" kindref="compound">LinOp</ref>). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>k</parametername>
</parameternamelist>
<parameterdescription>
<para>the number of lowest k eigen values. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>is_V</parametername>
</parameternamelist>
<parameterdescription>
<para>if set to true, the eigen vectors will be returned. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>maxiter</parametername>
</parameternamelist>
<parameterdescription>
<para>the maximum interation steps for each k. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>CvgCrit</parametername>
</parameternamelist>
<parameterdescription>
<para>the convergence criterion of the energy. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>is_row</parametername>
</parameternamelist>
<parameterdescription>
<para>whether the return eigen vectors should be in row-major form. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Tin</parametername>
</parameternamelist>
<parameterdescription>
<para>the initial vector, this should be rank-1 </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>max_krydim</parametername>
</parameternamelist>
<parameterdescription>
<para>the maximum krylov subspace dimension for each iteration. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>verbose</parametername>
</parameternamelist>
<parameterdescription>
<para>print out iteration info. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>[eigvals (<ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>), eigvecs (<ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>)(option)]</para>
</simplesect>
#description: This function calculate the eigen value problem using explicitly restarted Lanczos.</para>
<para>#Performance tune: For small linear dimension, try to reduce max_krydim.</para>
<para>#[Note] To use, define a linear operator with <ref refid="classcytnx_1_1LinOp" kindref="compound">LinOp</ref> class either by assign a custom function or create a class that inherit <ref refid="classcytnx_1_1LinOp" kindref="compound">LinOp</ref> (see <ref refid="classcytnx_1_1LinOp" kindref="compound">LinOp</ref> for further details) </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="880" column="17" declfile="include/linalg.hpp" declline="880" declcolumn="17"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1ae1d138b06f259478aa7f4276ebba9430" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &gt;</type>
        <definition>std::vector&lt; Tensor &gt; cytnx::linalg::Lanczos_Gnd</definition>
        <argsstring>(LinOp *Hop, const double &amp;CvgCrit=1.0e-14, const bool &amp;is_V=true, const Tensor &amp;Tin=Tensor(), const bool &amp;verbose=false, const unsigned int &amp;Maxiter=100000)</argsstring>
        <name>Lanczos_Gnd</name>
        <qualifiedname>cytnx::linalg::Lanczos_Gnd</qualifiedname>
        <param>
          <type><ref refid="classcytnx_1_1LinOp" kindref="compound">LinOp</ref> *</type>
          <declname>Hop</declname>
        </param>
        <param>
          <type>const double &amp;</type>
          <declname>CvgCrit</declname>
          <defval>1.0e-14</defval>
        </param>
        <param>
          <type>const bool &amp;</type>
          <declname>is_V</declname>
          <defval>true</defval>
        </param>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>Tin</declname>
          <defval><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>()</defval>
        </param>
        <param>
          <type>const bool &amp;</type>
          <declname>verbose</declname>
          <defval>false</defval>
        </param>
        <param>
          <type>const unsigned int &amp;</type>
          <declname>Maxiter</declname>
          <defval>100000</defval>
        </param>
        <briefdescription>
<para>perform Lanczos for hermitian/symmetric matrices or linear function to get ground state and lowest eigen value </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>Hop</parametername>
</parameternamelist>
<parameterdescription>
<para>the Linear Operator defined by <ref refid="classcytnx_1_1LinOp" kindref="compound">LinOp</ref> class or it&apos;s inheritance (see <ref refid="classcytnx_1_1LinOp" kindref="compound">LinOp</ref>). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>CvgCrit</parametername>
</parameternamelist>
<parameterdescription>
<para>the convergence criterion of the energy. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>is_V</parametername>
</parameternamelist>
<parameterdescription>
<para>if set to true, the eigen vectors will be returned. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Tin</parametername>
</parameternamelist>
<parameterdescription>
<para>the initial vector, this should be rank-1 </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>verbose</parametername>
</parameternamelist>
<parameterdescription>
<para>print out iteration info. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>maxiter</parametername>
</parameternamelist>
<parameterdescription>
<para>the maximum interation steps for each k. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>[eigvals (<ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>), eigvecs (<ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>)(option)]</para>
</simplesect>
#description: This function calculate the eigen value problem using naive Lanczos to get ground state and lowest eigen value.</para>
<para>#[Note] To use, define a linear operator with <ref refid="classcytnx_1_1LinOp" kindref="compound">LinOp</ref> class either by assign a custom function or create a class that inherit <ref refid="classcytnx_1_1LinOp" kindref="compound">LinOp</ref> (see <ref refid="classcytnx_1_1LinOp" kindref="compound">LinOp</ref> for further details) </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="909" column="17" declfile="include/linalg.hpp" declline="909" declcolumn="17"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a5f5b483903d6b472ca75b471eea8227b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; <ref refid="classcytnx_1_1UniTensor" kindref="compound">UniTensor</ref> &gt;</type>
        <definition>std::vector&lt; UniTensor &gt; cytnx::linalg::Lanczos_Gnd_Ut</definition>
        <argsstring>(LinOp *Hop, const UniTensor &amp;Tin, const double &amp;CvgCrit=1.0e-14, const bool &amp;is_V=true, const bool &amp;verbose=false, const unsigned int &amp;Maxiter=100000)</argsstring>
        <name>Lanczos_Gnd_Ut</name>
        <qualifiedname>cytnx::linalg::Lanczos_Gnd_Ut</qualifiedname>
        <param>
          <type><ref refid="classcytnx_1_1LinOp" kindref="compound">LinOp</ref> *</type>
          <declname>Hop</declname>
        </param>
        <param>
          <type>const <ref refid="classcytnx_1_1UniTensor" kindref="compound">UniTensor</ref> &amp;</type>
          <declname>Tin</declname>
        </param>
        <param>
          <type>const double &amp;</type>
          <declname>CvgCrit</declname>
          <defval>1.0e-14</defval>
        </param>
        <param>
          <type>const bool &amp;</type>
          <declname>is_V</declname>
          <defval>true</defval>
        </param>
        <param>
          <type>const bool &amp;</type>
          <declname>verbose</declname>
          <defval>false</defval>
        </param>
        <param>
          <type>const unsigned int &amp;</type>
          <declname>Maxiter</declname>
          <defval>100000</defval>
        </param>
        <briefdescription>
<para>perform Lanczos for hermitian/symmetric matrices or linear function to get ground state and lowest eigen value </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>Hop</parametername>
</parameternamelist>
<parameterdescription>
<para>the Linear Operator defined by <ref refid="classcytnx_1_1LinOp" kindref="compound">LinOp</ref> class or it&apos;s inheritance (see <ref refid="classcytnx_1_1LinOp" kindref="compound">LinOp</ref>). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>CvgCrit</parametername>
</parameternamelist>
<parameterdescription>
<para>the convergence criterion of the energy. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>is_V</parametername>
</parameternamelist>
<parameterdescription>
<para>if set to true, the eigen vectors will be returned. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Tin</parametername>
</parameternamelist>
<parameterdescription>
<para>the initial vector, this should be a <ref refid="classcytnx_1_1UniTensor" kindref="compound">UniTensor</ref>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>verbose</parametername>
</parameternamelist>
<parameterdescription>
<para>print out iteration info. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>maxiter</parametername>
</parameternamelist>
<parameterdescription>
<para>the maximum interation steps for each k. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>[eigvals (UniTensor::Dense), eigvecs (<ref refid="classcytnx_1_1UniTensor" kindref="compound">UniTensor</ref>)(option)]</para>
</simplesect>
#description: This function calculate the eigen value problem using naive Lanczos to get ground state and lowest eigen value.</para>
<para>#[Note] To use, define a linear operator with <ref refid="classcytnx_1_1LinOp" kindref="compound">LinOp</ref> class either by assign a custom function or create a class that inherit <ref refid="classcytnx_1_1LinOp" kindref="compound">LinOp</ref> (see <ref refid="classcytnx_1_1LinOp" kindref="compound">LinOp</ref> for further details) </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="937" column="17" declfile="include/linalg.hpp" declline="937" declcolumn="17"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a59fdd5725d0fe8c422dfe602629d34d7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &gt;</type>
        <definition>std::vector&lt; Tensor &gt; cytnx::linalg::Lstsq</definition>
        <argsstring>(const Tensor &amp;A, const Tensor &amp;b, const float &amp;rcond=-1)</argsstring>
        <name>Lstsq</name>
        <qualifiedname>cytnx::linalg::Lstsq</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <param>
          <type>const float &amp;</type>
          <declname>rcond</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
<para>Return the least-squares solution to a linear matrix equation. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>A</parametername>
</parameternamelist>
<parameterdescription>
<para>“Coefficient” matrix, must be two-dimensional. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Ordinate or “dependent variable” values, must be two-dimensional, the least-squares solution is calculated for each of the K columns of b. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rcond</parametername>
</parameternamelist>
<parameterdescription>
<para>Cut-off ratio for small singular values of a. For the purposes of rank determination, singular values are treated as zero if they are smaller than rcond times the largest singular value of A, If it is negative, the machine precision is used. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>[std::vector&lt;Tensors&gt;] <verbatim>1. the first tensor is least-squares solutions in the K columns.
2. the second tensor is the sums of squared residuals: Squared Euclidean 2-norm for each
</verbatim> column in b - a @ x. If the rank of a is &lt; N or M &lt;= N, this is a zero <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>.<orderedlist>
<listitem><para>the third tensor is the rank of matrix A.</para>
</listitem><listitem><para>the forth tensor is singular values of A.</para>
</listitem></orderedlist>
</para>
</simplesect>
#description: Computes the vector x that approximatively solves the equation A @ x = b. The equation may be under-, well-, or over-determined independent columns. If a is square and of full rank, then x (but for round-off error) is the “exact” solution of the equation. Else, x minimizes the Euclidean 2-norm || b - a x ||.</para>
<para>[Ke] </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="968" column="17" declfile="include/linalg.hpp" declline="968" declcolumn="17"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1aa65387e1199b5b0feb6ecaca3a7ab976" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor cytnx::linalg::Axpy</definition>
        <argsstring>(const Scalar &amp;a, const Tensor &amp;x, const Tensor &amp;y=Tensor())</argsstring>
        <name>Axpy</name>
        <qualifiedname>cytnx::linalg::Axpy</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1Scalar" kindref="compound">Scalar</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>y</declname>
          <defval><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>()</defval>
        </param>
        <briefdescription>
<para>Blas Axpy, performing return = a*x + y. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcytnx_1_1Scalar" kindref="compound">Scalar</ref>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>, can be any rank </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>y</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>, can be any rank </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>[<ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>]</para>
</simplesect>
#description: This function performs a*x+y where x,y are <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> and a is a <ref refid="classcytnx_1_1Scalar" kindref="compound">Scalar</ref>. The dtype of return <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> will be the strongest among x,y and a.</para>
<para>If y is not specify, then it performs a*x -&gt; return</para>
<para>#[Note] This will return a new tensor. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="989" column="12" declfile="include/linalg.hpp" declline="989" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1a414b247231f107dc34e52d221b615a99" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void cytnx::linalg::Axpy_</definition>
        <argsstring>(const Scalar &amp;a, const Tensor &amp;x, Tensor &amp;y)</argsstring>
        <name>Axpy_</name>
        <qualifiedname>cytnx::linalg::Axpy_</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1Scalar" kindref="compound">Scalar</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>y</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="991" column="10" declfile="include/linalg.hpp" declline="991" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespacecytnx_1_1linalg_1aad5bd110b48c053428e72ecceb2aa04d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor cytnx::linalg::Ger</definition>
        <argsstring>(const Tensor &amp;x, const Tensor &amp;y, const Scalar &amp;a=Scalar())</argsstring>
        <name>Ger</name>
        <qualifiedname>cytnx::linalg::Ger</qualifiedname>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>const <ref refid="classcytnx_1_1Scalar" kindref="compound">Scalar</ref> &amp;</type>
          <declname>a</declname>
          <defval><ref refid="classcytnx_1_1Scalar" kindref="compound">Scalar</ref>()</defval>
        </param>
        <briefdescription>
<para>Blas Ger, performing return = a*vec(x)*vec(y)^T. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>, rank-1 with size nx </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>y</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref>, rank-1 with size ny </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classcytnx_1_1Scalar" kindref="compound">Scalar</ref>, if not provided a = 1. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>[<ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> with shape (nx,ny)]</para>
</simplesect>
#description: This function performs a*x*y^T where x,y are rank-1 <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> with dimension nx and ny respectively; and a is a <ref refid="classcytnx_1_1Scalar" kindref="compound">Scalar</ref>. The dtype of return <ref refid="classcytnx_1_1Tensor" kindref="compound">Tensor</ref> will be the strongest among x,y and a.</para>
<para>#[Note] This will return a new tensor. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/linalg.hpp" line="1010" column="12" declfile="include/linalg.hpp" declline="1010" declcolumn="12"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>linear algebra related functions. </para>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="include/linalg.hpp" line="47" column="1"/>
  </compounddef>
</doxygen>
